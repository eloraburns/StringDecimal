On bounding
===========

The parse operation is bounded in two ways:
1. Numeric expressions without an "e" will consume O(n) in the final representation.
2. Numeric expressions with an "e" will consume O(n+e) in the final representation.

The add operation of an n and m digit pair is bounded by:
1. memory O(n+m), cpu O(n+m)

The subtract operation is just the add operation, but currently copies the second argument, so we get:
1. memory O(3(n+m)+m), cpu O(n+m)

The multiply operation is implemented with a 2-nested accumulation loop:
1. memory O(n+m), cpu O(n*m)

The divide operation is implemented in terms of add, subtract, and multiply, with intermediate rounding based on precision and final rounding based on places:
1. memory O(n+m+_precision+places), cpu O(n*m*_precision+places)

Bugs
====
* Divide very probably uses more memory than necessary.  Do we need _precision*2 reciprocal digits to guarantee convergence?
* Internal operations shouldn't go back through strings; just pass around internal representations
* Mutations should be avoided
* Prefer passing around whole values instead of an array here and an int there
* Divide iterations could be bounded more tightly; one iteration per digit is probably too much (need to look up the convergence rate guaranteed by the algorithm)
